-----------
-- Goals --
-----------
 

From Dagstuhl:
  
  ++ Support common "wrapper" pattern ++
    
    - After further review, we could already do this
      - let-expressions already solved the problem described in
        KÃ¤stner et al. "Guaranteeing Syntactic Correctness for all...", 2009
      - Transformation to add wrapper are arguably "local" (Shriram's comment)
        Felleisen, 1991
                      
  ++ Unify "annotative" and "compositional" approaches ++    **BIG DEAL**
      
      annotative:    CPP, CIDE, "industry tools", choice calculus
      compositional: GenVoca/AHEAD (inheritance, mixins), Caesar (+aspects)
    
    - After further review, not clear that we can truly do this yet!
      - (we'll discuss limitations later)
      - (others have tried (XCVL), I think we're already closer)

  ++ Support for arbitrary number of copies of a feature ++

    - e.g. add a wolf to Tim's ABP game; now add n wolves
    - This doesn't even really make sense in current CC


From our own wishlist:

  ++ Dimension reuse ++

    - Want to define (dim Par<xTag,yTag> in Par<x,y>) once, and reuse it
      in twice, thrice, and every other function we want to vary the
      parameter name of
    
  ++ Better support for feature modeling / selection constraints ++
  
    - Currently only explicitly AND and XOR
      - OPTIONAL is easy, OR is ugly, n..m is ??



----------------
-- Basic Idea --
----------------

  
  1. Replace let with abstraction and application
         let v = b in u   <=>   (\v. u) b
     - This gives us separability, a distinguishing feature of
       comopositional approaches
     - It also gives us *tons* of power (all of it--too much?)
       - At first we thought so, now we use it!
         - e.g. infinitely recursive CC expressions put to use!
  
  2. Eagerly apply beta-reduction.
         (\v. {v,v}) (dim A<a,b> in A<1,2>)
           A.a => {1,1}
           A.b => {2,2}
         {dim A<a,b> in A<1,2>,dim A<a,b> in A<1,2>}
           A.a,A.a => {1,1}
           A.a,A.b => {1,2}
           A.b,A.a => {2,1}
           A.b,A.b => {2,2}
     - Previously, expanded lets after dimension elimination
     - Now, apply functions before dimension elimination
     - This allows us to "meta-program" CC expressions
       - dimension reuse, CC generation
         - OR is ugly? write a function to generate it!

  3. There is no step 3!



----------------
-- Code Time! --
----------------

  
  I'll wait...



-----------------
-- Limitations --
-----------------

  
  - Biggie: No way to "process" (examine/transform) the data in structures...
    - This prevents us from truly implementing mixins/aspects/etc.
    - We must instead "seed" references into the existing tree structure
      - This is basically the approach of XCVL
      - If we're going to claim unification, we may have to do better
    
    
    IDEA: Utilize an object-language-specific composition operator when two
          structure nodes are applied (same solution as AHEAD)
           - Compositions are fundamentally tied to the object language

  - No way to vary/parameterize dimension names and tag names
    - Can separate feature implementations from feature modeling, but
      dimension and tag names cease to be informative



---------------------
-- Goals Revisited --
---------------------

  
  ++ unify "annotative" and "compositional" approaches ++
    
      Partially achieved.
      
      More flexible than previous attempts (XCVL), but still cannot model
      inheritance, mixins, or aspects directly.

  
  ++ support for arbitrary number of copies of a feature ++

      Done!
  
  
  ++ dimension reuse ++

      Done!

  
  ++ better support for feature modeling / selection constraints ++

      Mostly achieved.
      
      Full separation of feature implementations and feature constraints
      is possible, and the functional approach to constructing feature
      constraints is powerful.
      
      Problem: dimension and tag names become generic and not meaningful.  

      Open problem: cross-tree constraints??
